<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>From James, to Suri</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #memoryDialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #d4af37;
            padding: 30px;
            border: 3px solid #8b7355;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            display: none;
            max-width: 500px;
            z-index: 200;
        }

        #memoryDialog h2 {
            margin-bottom: 15px;
            color: #fff;
        }

        #memoryDialog button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #8b7355;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 5px;
        }

        #memoryDialog button:hover {
            background: #a08968;
        }

        #interactPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #d4af37;
            padding: 10px 20px;
            border: 2px solid #8b7355;
            border-radius: 5px;
            font-size: 16px;
            display: none;
            z-index: 50;
        }
        #labyrinthGame {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    display: none;
    z-index: 300;
}
#mobileControls {
    position: fixed;
    bottom: 20px;
    left: 20px;  /* Changed from center to left */
    transform: none;  /* Remove centering transform */
    display: none;
    z-index: 100;
    gap: 10px;
}

.mobile-btn {
    width: 60px;
    height: 60px;
    background: rgba(139, 115, 85, 0.7);
    border: 2px solid #d4af37;
    border-radius: 10px;
    color: #fff;
    font-size: 24px;
    font-weight: bold;
    touch-action: none;
    user-select: none;
}

.mobile-btn:active {
    background: rgba(160, 137, 104, 0.9);
}

#mobileJoystick {
    display: grid;
    grid-template-columns: repeat(3, 60px);
    grid-template-rows: repeat(3, 60px);
    gap: 5px;
}

#touchLookArea {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: none;
    pointer-events: none;
}

#touchLookArea.active {
    pointer-events: auto;
}
#itemDialog {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    color: #d4af37;
    padding: 30px;
    border: 3px solid #8b7355;
    border-radius: 10px;
    text-align: center;
    display: none;
    max-width: 600px;
    z-index: 302;
}

#itemDialog h2 {
    margin-bottom: 15px;
    color: #fff;
}

#itemDialog img {
    max-width: 400px;
    max-height: 300px;
    margin: 10px 0;
    border: 2px solid #8b7355;
    border-radius: 5px;
}
#itemDialog p {
    margin: 15px 0;
    font-size: 16px;
}

#itemDialog button {
    margin-top: 15px;
    padding: 10px 20px;
    background: #8b7355;
    color: #fff;
    border: none;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    border-radius: 5px;
}

#itemDialog button:hover {
    background: #a08968;
}

#memoriesPage {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    display: none;
    z-index: 300;
    overflow-y: auto;
    padding: 40px;
}

#memoriesContent {
    max-width: 1200px;
    margin: 0 auto;
    color: #d4af37;
}

#memoriesContent h1 {
    text-align: center;
    color: #fff;
    margin-bottom: 40px;
}

.memory-item {
    background: rgba(0, 0, 0, 0.8);
    border: 3px solid #8b7355;
    border-radius: 10px;
    padding: 30px;
    margin-bottom: 30px;
}

.memory-item h2 {
    color: #d4af37;
    margin-bottom: 15px;
}

.memory-item img {
    max-width: 100%;
    height: auto;
    border: 2px solid #8b7355;
    border-radius: 5px;
    margin: 15px 0;
}

.memory-item p {
    font-size: 18px;
    line-height: 1.6;
}

#closeMemoriesBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 30px;
    background: #8b7355;
    color: #fff;
    border: none;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    border-radius: 5px;
    z-index: 301;
}

#closeMemoriesBtn:hover {
    background: #a08968;
}
#letterPage {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    display: none;
    z-index: 300;
    overflow-y: auto;
    padding: 40px;
}

#letterContent {
    max-width: 900px;
    margin: 0 auto;
    color: #d4af37;
}

#letterContent h1 {
    text-align: center;
    color: #fff;
    margin-bottom: 40px;
}

.letter-text {
    background: rgba(0, 0, 0, 0.8);
    border: 3px solid #8b7355;
    border-radius: 10px;
    padding: 40px;
    font-size: 18px;
    line-height: 1.8;
    white-space: pre-wrap;
}

#closeLetterBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 30px;
    background: #8b7355;
    color: #fff;
    border: none;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    border-radius: 5px;
    z-index: 301;
}

#closeLetterBtn:hover {
    background: #a08968;
}
    </style>
</head>
<body>
<div id="gameContainer">
    <div id="touchLookArea"></div>
    <div id="mobileControls">
        <div id="mobileJoystick">
            <div></div>
            <button class="mobile-btn" data-key="w">↑</button>
            <div></div>
            <button class="mobile-btn" data-key="a">←</button>
            <button class="mobile-btn" data-key="s">↓</button>
            <button class="mobile-btn" data-key="d">→</button>
            <div></div>
            <button class="mobile-btn" data-key="e">E</button>
            <div></div>
        </div>
    </div>
    <div id="interactPrompt">Press [E] to interact</div>
    <div id="memoryDialog">
        <h2 id="memoryTitle"></h2>
        <p id="memoryText"></p>
        <button onclick="closeMemory()">Continue (E)</button>
    </div>
    <div id="memoriesPage">
        <button id="closeMemoriesBtn" onclick="closeMemoriesPage()">Back</button>
        <div id="memoriesContent">
            <h1>Reminds you of anything?</h1>
        </div>
    </div>

    <div id="letterPage">
        <button id="closeLetterBtn" onclick="closeLetterPage()">Back</button>
        <div id="letterContent">
            <h1>A Letter for You</h1>
            <div class="letter-text">
                <p>Dear Darling,<br>
I often express, during our conversations, my love and admiration for you. However I rarely talk in detail about why I think so, also, but not only, because you don't let me. The first reason why I love you is that of why most people like each other (after the physical look, something that both of us agree in not taking in consideration), and that is your personality. It's clear you are a person especially dedicated to the thought and the mind rather than to the body, which is something you share with me, although not in the same ways. This makes you prone to reflections which make you a person, in my eyes, refreshingly interesting. You are also a very direct and mentally imposing person, which is something I pretty much am too in real life, relative to my culture at least, and that I really admire. At the same time, you also care deeply about your friends and you are very delicate too when needed. Furthermore, you are extremely witty, smart and good in most things you do, so it's really no wonder I'm not the first person that falls in love with your personality. 
The second reason why I love you is, again, common to many human relationships: the way you act toward me. I am one of the lucky few who you care about and are nice and amazing towards, and while that doesn't mean you aren't harsh to me when needed, it still makes me really enjoy and crave the time I spend with you. Those two reasons are obvious and I started, over time, to take them for granted, which is a mistake, as the way we are and the way we act to each other is the foundation of us (and a very strong one!), and they should be remembered. Related to, but not the same as, the past reason is the fact you are, if not always, very often there for me, which is something I really need and enjoy from someone like you, being the lonely individual I am. This not only makes me closer to you and like you more as you are a rock for me, but also brings our relationship from a normal one of two people liking each other in how they are and behave to something deeper, as we both trust and rely on each other and are mostly there when the other needs. This brings me a sense of security, which is something I really value, also due to my past experiences: you make me feel safe with you and this makes me love and trust you completely. 
Changing topic, another reason I love you is your ideals. While I would obviously not mind you or any other of my friend (the absence of "s" is intentional) having a different political or religious opinion than mine, it's impossible to avoid that the fact we have makes us closer and allows us to understand each other better. At the same time we also have our differences, and this makes us even better and stronger, as we wouldn't be able to otherwise grow from this relationship and we'd just be copies of each other. 
Those are the most important reasons why I love you. There are many others, but I want to keep this letter short and my thoughts clear and concise.
<br><br>
Thank you for everything, I love you
James </p>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 1, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        // Player controls
        const moveSpeed = 0.1;
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        let isPointerLocked = false;

        const memoryData = [
            { position: [0, -10], name: "6/10/2024", content: "You asked me to join my Genshin world when we didn't know each other at all... remember how I thought you were a boy at the start? Because you made fun of me that I had no social life :D" },
            { position: [0, -20], name: "Minecraft hangout", content: "This was surprisingly early when we met, and I had fun playing survival (and then creative!) with you, although you made fun of my ugly building abilities..." },
            { position: [0, -30], name: "Your beautiful builds", content: "I wish I could be as creative and good in those things as you <3 This looks beautiful" },
            { position: [0, -40], name: "Sso", content: "Your photos from sso are so cute and I really love them... this is my favourite!" },
            { position: [0, -50], name: "...and sso again", content: "And you character is so fucking beautiful!" },
        ];

        const textMessages = [
            { position: [0, -60], text: "Thank you for being here\nwith me dear" },
            { position: [0, -70], text: "Every moment with you\nhas been special <3" },
            { position: [0, -80], text: "We sent each other \nover 120k messages!" },
            { position: [0, -90], text: "Here are a few poems \nI wrote for you!" },
        ];

const poemPapers = [
    { position: [0, -100], poem: "In deep darkness\nMy heart cries alone,\nFor it is helpless in such a world\nHe wasn’t meant to be part of.\nAnd while I cough\nWeak and whining,\nA hand grabs my cloth,\nAnd with warmth, finally,\nI can close my eyes." },
    { position: [0, -110], poem: "Silently I hear,\nAs noisy screams\nFill my ears with words\nThat I barely understand.\nNeither stands back,\nBoth want truth,\nBoth think are right,\nNeither truly is.\nUnderstanding now,\nAs they fight\nTo their death inside,\nSilently I watch." },
    { position: [0, -120], poem: "Near a river\nAn indomitable soul\nDrank secure,\nAs an arrow glowed behind.\nAnd suddenly\nAll the birds flew away,\nAs the water\nGot dyed in red.\nThe soul stopped drinking,\nAnd looking back,\nThere was a man,\nAnd an arrow through his neck." },
    { position: [0, -130], poem: "The sun looked down,\nAs a red figure rises,\nProud and sure,\nSevere and high.\nAnd for a moment,\nAs such moon glowed\nWith rising might,\nThe sun stood pensive." },
    { position: [0, -140], poem: "At the end of the world\nThere was an angel,\nIn front of the everlasting abyss,\nWith its little servant.\nThey were the last who stood,\nAnd for the last night\nBefore the time would end,\nA last order gave:\n\“Bring me now\nThe purest souls\nTo sing tonight\nOne last time\”" },
    { position: [0, -150], poem: "And back it got\nA heart of stone\nTough and heavy\nAs the servant said:\n\"All the souls are gone\nIn the depth of Tartarus;\nOnly this survived, as so\nStrong the world forged her to be\"\nAnd so she sang." },
];

const itemData = [
    {
        title: "Cryo boss with Kaeya",
        image: "assets/1.png",
        text: "I fought most bosses with you watching me from the side and laughing at me... and it was so fun to do it! Expecially when you gave me restrictions and I had to fight this boss with Kaeya without dying <3"
    },
    {
        title: "Dendro boss with Kinich",
        image: "assets/2.png",
        text: "This one I didn't fail :D"
    },
    {
        title: "Cryo flower",
        image: "assets/3.png",
        text: "I soloed so many bosses with Kinich alone!"
    },
    {
        title: "Puzzles...",
        image: "assets/4.png",
        text: "I'M NOT STUPID I SWEAR T_T"
    },
    {
        title: "Mount Mingyuan",
        image: "assets/5.png",
        text: "We went here after 10 hours straight of playing Genshin together!"
    }
];

const letterObject = { position: [0, -160], name: "A Letter for You" };

let poemPaperObjects = [];
const finalImage = { position: [0, -170], name: "With love", content: "Thanks, for everything." };
let finalImageObject = null;

const finalMessage = { position: [0, -180], text: "From James\nTo Suri" };
let finalMessageObject = null;
let textMessageObjects = [];

        let memoryObjects = [];
        let currentMemory = null;
        let floatingTexts = [];
let isLabyrinthOpen = false;
let labyrinthCanvas, labyrinthCtx;
let playerPos = { x: 1, y: 1 };
let labyrinthKeys = {};
let letterObjectMesh = null;
const cellSize = 40;
let lastMoveTime = 0;
const moveDelay = 150; // milliseconds between moves
        // Texture loader
        const textureLoader = new THREE.TextureLoader();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambientLight);

        // Player's torch light
        const pointLight = new THREE.PointLight(0xffcc88, 2, 15);
        pointLight.position.copy(camera.position);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 1024;
        pointLight.shadow.mapSize.height = 1024;
        scene.add(pointLight);

function createCorridor() {
    const corridorLength = 420;
    const corridorWidth = 6;
    const wallHeight = 4;

    // Load textures (will use default colors if textures don't load)
    const floorTexture = textureLoader.load(
        'assets/floor_texture.png',
        undefined,
        undefined,
        () => console.log('Floor texture not found, using default color')
    );
    floorTexture.wrapS = THREE.RepeatWrapping;
    floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(6, 400);

    const wallTexture = textureLoader.load(
        'assets/wall_texture.png',
        undefined,
        undefined,
        () => console.log('Wall texture not found, using default color')
    );
    wallTexture.wrapS = THREE.RepeatWrapping;
    wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(100, 1);

    const ceilingTexture = textureLoader.load(
        'assets/ceiling_texture.png',
        undefined,
        undefined,
        () => console.log('Ceiling texture not found, using default color')
    );
    ceilingTexture.wrapS = THREE.RepeatWrapping;
    ceilingTexture.wrapT = THREE.RepeatWrapping;
    ceilingTexture.repeat.set(6, 400);

    // Load baseboard texture
    const baseboardTexture = textureLoader.load(
        'assets/baseboard_texture.png',
        undefined,
        undefined,
        () => console.log('Baseboard texture not found, using default color')
    );
    baseboardTexture.wrapS = THREE.RepeatWrapping;
    baseboardTexture.wrapT = THREE.RepeatWrapping;
    baseboardTexture.repeat.set(100, 1); // Adjust repeat values as needed

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
    const floorMaterial = new THREE.MeshStandardMaterial({ 
        map: floorTexture,
        color: 0x2a2438,
        roughness: 0.8,
        metalness: 0.2
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.z = -corridorLength / 2 + 90;
    floor.receiveShadow = true;
    scene.add(floor);

    // Ceiling
    const ceilingMaterial = new THREE.MeshStandardMaterial({ 
        map: ceilingTexture,
        color: 0x2a2438,
        roughness: 0.8,
        metalness: 0.2
    });
    const ceiling = new THREE.Mesh(floorGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = wallHeight;
    ceiling.position.z = -corridorLength / 2 + 90;
    ceiling.receiveShadow = true;
    scene.add(ceiling);

    // Left wall
    const wallGeometry = new THREE.PlaneGeometry(corridorLength, wallHeight);
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        map: wallTexture,
        color: 0x3d3450,
        roughness: 0.9,
        metalness: 0.1
    });
    const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.x = -corridorWidth / 2;
    leftWall.position.y = wallHeight / 2;
    leftWall.position.z = -corridorLength / 2 + 90;
    leftWall.receiveShadow = true;
    leftWall.renderOrder = 0;
    scene.add(leftWall);

    // Right wall
    const rightWall = new THREE.Mesh(wallGeometry, wallMaterial.clone());
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.x = corridorWidth / 2;
    rightWall.position.y = wallHeight / 2;
    rightWall.position.z = -corridorLength / 2 + 90;
    rightWall.receiveShadow = true;
    rightWall.renderOrder = 0;
    scene.add(rightWall);

    // Baseboard setup
    const baseboardHeight = 0.02; // Adjust this value to change height
    const baseboardGeometry = new THREE.PlaneGeometry(corridorLength, baseboardHeight);
    const baseboardMaterial = new THREE.MeshStandardMaterial({ 
        map: baseboardTexture,
        color: 0x6e6858,
        roughness: 0.7,
        metalness: 0.3
    });

    // Left wall baseboard
    const leftBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
    leftBaseboard.rotation.y = Math.PI / 2;
    leftBaseboard.position.x = -corridorWidth / 2 + 0.001;
    leftBaseboard.position.y = baseboardHeight / 2;
    leftBaseboard.position.z = -corridorLength / 2 + 90;
    leftBaseboard.receiveShadow = true;
    leftBaseboard.renderOrder = 1;
    scene.add(leftBaseboard);

    // Right wall baseboard
    const rightBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial.clone());
    rightBaseboard.rotation.y = -Math.PI / 2;
    rightBaseboard.position.x = corridorWidth / 2 - 0.001;
    rightBaseboard.position.y = baseboardHeight / 2;
    rightBaseboard.position.z = -corridorLength / 2 + 90;
    rightBaseboard.receiveShadow = true;
    rightBaseboard.renderOrder = 1;
    scene.add(rightBaseboard);
    // Top baseboard (crown molding) setup
const topBaseboardHeight = 0.055; // Adjust this value to change height
const topBaseboardGeometry = new THREE.PlaneGeometry(corridorLength, topBaseboardHeight);
const topBaseboardMaterial = new THREE.MeshStandardMaterial({ 
    map: baseboardTexture,
    color: 0x6e6858,
    roughness: 0.7,
    metalness: 0.3
});

// Left wall top baseboard
const leftTopBaseboard = new THREE.Mesh(topBaseboardGeometry, topBaseboardMaterial);
leftTopBaseboard.rotation.y = Math.PI / 2;
leftTopBaseboard.position.x = -corridorWidth / 2 + 0.01;
leftTopBaseboard.position.y = wallHeight - (topBaseboardHeight / 2); // Position at top of wall
leftTopBaseboard.position.z = -corridorLength / 2 + 90;
leftTopBaseboard.receiveShadow = true;
leftTopBaseboard.renderOrder = 1;
scene.add(leftTopBaseboard);

// Right wall top baseboard
const rightTopBaseboard = new THREE.Mesh(topBaseboardGeometry, topBaseboardMaterial.clone());
rightTopBaseboard.rotation.y = -Math.PI / 2;
rightTopBaseboard.position.x = corridorWidth / 2 - 0.01;
rightTopBaseboard.position.y = wallHeight - (topBaseboardHeight / 2); // Position at top of wall
rightTopBaseboard.position.z = -corridorLength / 2 + 90;
rightTopBaseboard.receiveShadow = true;
rightTopBaseboard.renderOrder = 1;
scene.add(rightTopBaseboard);
}

        // Create floating 3D text
        function createFloatingText(text, position, fontSize = 0.5) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.strokeStyle = '#8b7355';
            context.lineWidth = 4;
            context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
            
            context.fillStyle = '#d4af37';
            context.font = 'bold 28px cursive';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Split text by newlines and draw each line
            const lines = text.split('\n');
            const lineHeight = 40;
            const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2);
            
            lines.forEach((line, index) => {
                context.fillText(line, canvas.width / 2, startY + (index * lineHeight));
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            const geometry = new THREE.PlaneGeometry(2.5, 1.25);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position[0], position[1], position[2]);
            mesh.userData.isFloatingText = true;
            mesh.userData.startZ = position[2];
            
            scene.add(mesh);
            floatingTexts.push(mesh);
        }
// Create memory images on floor
function createMemoryObjects() {
    memoryData.forEach((data, index) => {
        const geometry = new THREE.PlaneGeometry(3, 3); // Temporary size
        const memoryMaterial = new THREE.MeshBasicMaterial({ 
            transparent: true,
            side: THREE.DoubleSide,
            opacity: 0
        });
        
        const plane = new THREE.Mesh(geometry, memoryMaterial);
        plane.position.set(data.position[0], 2, data.position[1]);
        plane.userData = { 
            isMemory: true, 
            name: data.name, 
            content: data.content,
            index: index
        };
        
        // Load memory image texture
        const memoryTexture = textureLoader.load(
            `assets/memory${index + 1}.png`,
            (texture) => {
                // Success callback - resize based on actual image dimensions
                const img = texture.image;
                const aspectRatio = img.width / img.height;
                const baseHeight = 3; // Bigger base size
                const width = baseHeight * aspectRatio;
                
                plane.geometry.dispose();
                plane.geometry = new THREE.PlaneGeometry(width, baseHeight);
                memoryMaterial.map = texture;
                memoryMaterial.needsUpdate = true;
            },
            undefined,
            () => {
                console.log(`Memory image ${index + 1} not found, using default`);
                // Create default golden circle if image fails to load
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.5, '#d4af37');
                gradient.addColorStop(1, '#8b7355');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 128, 128);
                memoryMaterial.map = new THREE.CanvasTexture(canvas);
                memoryMaterial.needsUpdate = true;
            }
        );
        
        scene.add(plane);
        memoryObjects.push(plane);
    });
}

// Create text message objects floating in air
function createTextMessageObjects() {
    textMessages.forEach((data, index) => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 256;
        
        context.fillStyle = 'rgba(0, 0, 0, 0.9)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        context.strokeStyle = '#8b7355';
        context.lineWidth = 4;
        context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
        
        context.fillStyle = '#d4af37';
        context.font = 'bold 32px cursive';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Split text by newlines and draw each line
        const lines = data.text.split('\n');
        const lineHeight = 45;
        const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2);
        
        lines.forEach((line, i) => {
            context.fillText(line, canvas.width / 2, startY + (i * lineHeight));
        });
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            opacity: 0
        });
        
        const geometry = new THREE.PlaneGeometry(4, 2);
        const plane = new THREE.Mesh(geometry, material);
        // No rotation - keeps it vertical/floating
        plane.position.set(data.position[0], 2, data.position[1]); // y=2 makes it float at eye level
        plane.userData = { 
            isTextMessage: true,
            index: index
        };
        
        scene.add(plane);
        textMessageObjects.push(plane);
    });
}

// Create floating poem papers
function createPoemPapers() {
    poemPapers.forEach((data, index) => {
        const lines = data.poem.split('\n');
        const lineCount = lines.length;
        
        // Adjust canvas height and font size based on line count
        let canvasHeight = 1000;
        let fontSize = 28;
        let lineHeight = 45;
        
        if (lineCount > 15) {
            // For very long poems
            canvasHeight = 1400;
            fontSize = 24;
            lineHeight = 38;
        } else if (lineCount > 10) {
            // For medium-long poems
            canvasHeight = 1200;
            fontSize = 26;
            lineHeight = 42;
        }
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = canvasHeight;
        
        // Paper-like background color
        context.fillStyle = '#f4e8d0';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add slight paper texture with lines
        context.strokeStyle = 'rgba(200, 180, 150, 0.3)';
        context.lineWidth = 1;
        for (let i = 80; i < canvas.height - 80; i += lineHeight) {
            context.beginPath();
            context.moveTo(80, i);
            context.lineTo(canvas.width - 80, i);
            context.stroke();
        }
        
        // Paper border
        context.strokeStyle = '#d4c4a8';
        context.lineWidth = 3;
        context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
        
        // Poem text - smaller and darker for readability on paper
        context.fillStyle = '#2a2a2a';
        context.font = `${fontSize}px cursive`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Draw each line
        const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2);
        
        lines.forEach((line, i) => {
            context.fillText(line, canvas.width / 2, startY + (i * lineHeight));
        });
        
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            opacity: 0
        });
        
        // Adjust geometry height based on canvas height
        const paperWidth = 6;
        const paperHeight = (canvasHeight / 1000) * 7.5; // Scale proportionally
        const geometry = new THREE.PlaneGeometry(paperWidth, paperHeight);
        const plane = new THREE.Mesh(geometry, material);
        plane.position.set(data.position[0], 2, data.position[1]);
        plane.userData = { 
            isPoemPaper: true,
            index: index
        };
        
        scene.add(plane);
        poemPaperObjects.push(plane);
    });
}

// Create final floating image
function createFinalImage() {
    const geometry = new THREE.PlaneGeometry(3, 3);
    const memoryMaterial = new THREE.MeshBasicMaterial({ 
        transparent: true,
        side: THREE.DoubleSide,
        opacity: 0
    });
    
    const plane = new THREE.Mesh(geometry, memoryMaterial);
    plane.position.set(finalImage.position[0], 2, finalImage.position[1]);
    plane.userData = { 
        isMemory: true, 
        name: finalImage.name, 
        content: finalImage.content,
        index: 'final'
    };
    
    const memoryTexture = textureLoader.load(
        'assets/final.png',
        (texture) => {
            const img = texture.image;
            const aspectRatio = img.width / img.height;
            const baseHeight = 3;
            const width = baseHeight * aspectRatio;
            
            plane.geometry.dispose();
            plane.geometry = new THREE.PlaneGeometry(width, baseHeight);
            memoryMaterial.map = texture;
            memoryMaterial.needsUpdate = true;
        },
        undefined,
        () => {
            console.log('Final image not found, using default');
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(0.5, '#d4af37');
            gradient.addColorStop(1, '#8b7355');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            memoryMaterial.map = new THREE.CanvasTexture(canvas);
            memoryMaterial.needsUpdate = true;
        }
    );
    
    scene.add(plane);
    finalImageObject = plane;
}
// Check letter object
if (letterObjectMesh) {
    const distance = camera.position.distanceTo(letterObjectMesh.position);
    if (distance < 2 && distance < minDistance) {
        minDistance = distance;
        nearestMemory = letterObjectMesh;
    }
}
// Create final message
function createFinalMessage() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 256;
    
    context.fillStyle = 'rgba(0, 0, 0, 0.9)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    context.strokeStyle = '#8b7355';
    context.lineWidth = 4;
    context.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
    
    context.fillStyle = '#d4af37';
    context.font = 'bold 32px cursive';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    const lines = finalMessage.text.split('\n');
    const lineHeight = 45;
    const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight / 2);
    
    lines.forEach((line, i) => {
        context.fillText(line, canvas.width / 2, startY + (i * lineHeight));
    });
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({ 
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        opacity: 0
    });
    
    const geometry = new THREE.PlaneGeometry(4, 2);
    const plane = new THREE.Mesh(geometry, material);
    plane.position.set(finalMessage.position[0], 2, finalMessage.position[1]);
    plane.userData = { 
        isFinalMessage: true
    };
    
    scene.add(plane);
    finalMessageObject = plane;
}

// Create letter object
// Create letter object
function createLetterObject() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 1000;
    
    // Envelope/paper-like background
    context.fillStyle = '#f4e8d0';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Border
    context.strokeStyle = '#d4c4a8';
    context.lineWidth = 3;
    context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
    
    // Letter text only
    context.fillStyle = '#8b7355';
    context.font = 'bold 48px cursive';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText('A Letter for You', canvas.width / 2, canvas.height / 2);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({ 
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        opacity: 0
    });
    
    const geometry = new THREE.PlaneGeometry(6, 7.5);
    const plane = new THREE.Mesh(geometry, material);
    plane.position.set(letterObject.position[0], 2, letterObject.position[1]);
    plane.userData = { 
        isLetter: true
    };
    
    scene.add(plane);
    letterObjectMesh = plane;
}

let isItemDialogOpen = false;
        createCorridor();
        createMemoryObjects();
        createTextMessageObjects();
        createPoemPapers(); 
        createFinalImage();
        createFinalMessage();
        createLetterObject();

        // Create floating texts at start
        createFloatingText('Hello, darling!\nUse WASD + Mouse to explore', [0, 2.5, 2]);

        // Mobile detection and controls - ADD THIS SECTION HERE
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('touchLookArea').style.display = 'block';
            document.getElementById('touchLookArea').classList.add('active');
            
            // Touch look controls
            let lastTouchX = 0;
            let lastTouchY = 0;
            
            const touchArea = document.getElementById('touchLookArea');
            
            touchArea.addEventListener('touchstart', (e) => {
                if (e.touches.length > 0) {
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            });
            
            touchArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;
                    
                    mouseX -= deltaX * 0.005;
                    mouseY -= deltaY * 0.005;
                    mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
                    
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            });
            
            // Mobile button controls
            document.querySelectorAll('.mobile-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const key = btn.getAttribute('data-key');
                    keys[key] = true;
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const key = btn.getAttribute('data-key');
                    keys[key] = false;
                });
            });
        }

        // Mouse controls (existing code continues here)
        document.addEventListener('click', () => {

    

        // Mouse controls
        document.addEventListener('click', () => {
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseX -= e.movementX * 0.002;
                mouseY -= e.movementY * 0.002;
                mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
            }
        });

document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'e' && currentMemory) {
        closeMemory();
    }
if (e.key.toLowerCase() === 'escape') {
    if (document.getElementById('memoriesPage').style.display === 'block') {
        closeMemoriesPage();
    } else if (document.getElementById('letterPage').style.display === 'block') {
        closeLetterPage();
    }
}
});

document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

document.addEventListener('keyup', (e) => {
    if (isLabyrinthOpen) {
        labyrinthKeys[e.key.toLowerCase()] = false;
    } else {
        keys[e.key.toLowerCase()] = false;
    }
});

// Check proximity to memory objects and text messages
function checkMemoryProximity() {
    let nearestMemory = null;
    let minDistance = Infinity;

    memoryObjects.forEach(obj => {
        const distance = camera.position.distanceTo(obj.position);
        if (distance < 2 && distance < minDistance) {
            minDistance = distance;
            nearestMemory = obj;
        }
    });
    
    // Check final image
    if (finalImageObject) {
        const distance = camera.position.distanceTo(finalImageObject.position);
        if (distance < 2 && distance < minDistance) {
            minDistance = distance;
            nearestMemory = finalImageObject;
        }
    }

    // Check letter object
    if (letterObjectMesh) {
        const distance = camera.position.distanceTo(letterObjectMesh.position);
        if (distance < 2 && distance < minDistance) {
            minDistance = distance;
            nearestMemory = letterObjectMesh;
        }
    }

    if (nearestMemory && !currentMemory) {
        document.getElementById('interactPrompt').style.display = 'block';
        if (keys['e']) {
            openMemory(nearestMemory.userData);
        }
    } else {
        document.getElementById('interactPrompt').style.display = 'none';
    }
    
    // Fade in/out letter object based on proximity
    if (letterObjectMesh) {
        const distance = camera.position.distanceTo(letterObjectMesh.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            letterObjectMesh.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            letterObjectMesh.material.opacity = 0;
        }
    }
    
    // Fade in/out text messages based on proximity
    textMessageObjects.forEach(textObj => {
        const distance = camera.position.distanceTo(textObj.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            textObj.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            textObj.material.opacity = 0;
        }
    });

    // Fade in/out poem papers based on proximity
    poemPaperObjects.forEach(poemObj => {
        const distance = camera.position.distanceTo(poemObj.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            poemObj.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            poemObj.material.opacity = 0;
        }
    });
    
    // Fade in/out final message based on proximity
    if (finalMessageObject) {
        const distance = camera.position.distanceTo(finalMessageObject.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            finalMessageObject.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            finalMessageObject.material.opacity = 0;
        }
    }
    
    // Fade in/out memory images based on proximity
    memoryObjects.forEach(memObj => {
        const distance = camera.position.distanceTo(memObj.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            memObj.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            memObj.material.opacity = 0;
        }
    });

    // Fade in/out final image based on proximity
    if (finalImageObject) {
        const distance = camera.position.distanceTo(finalImageObject.position);
        const fadeDistance = 8;
        
        if (distance < fadeDistance) {
            const opacity = 1 - (distance / fadeDistance);
            finalImageObject.material.opacity = Math.max(0, Math.min(1, opacity));
        } else {
            finalImageObject.material.opacity = 0;
        }
    }
}
        // Check if player passed floating texts
        function checkFloatingTexts() {
            floatingTexts.forEach((text, index) => {
                if (camera.position.z < text.position.z - 2) {
                    scene.remove(text);
                    floatingTexts.splice(index, 1);
                }
            });
        }

function openMemory(data) {
    // Check if this is the letter
    if (data.isLetter) {
        openLetterPage();
        keys['e'] = false;
        return;
    }
    
    // Check if this is the final image
    if (data.index === 'final') {
        openMemoriesPage();
        return;
    }
    
    currentMemory = data;
    document.getElementById('memoryTitle').textContent = data.name;
    document.getElementById('memoryText').textContent = data.content;
    document.getElementById('memoryDialog').style.display = 'block';
    keys['e'] = false;
}

        function closeMemory() {
            document.getElementById('memoryDialog').style.display = 'none';
            currentMemory = null;
            keys['e'] = false;
        }


function showItemDialog(itemIndex) {
    if (itemIndex >= itemData.length) return;
    
    isItemDialogOpen = true;
    const item = itemData[itemIndex];
    
    document.getElementById('itemTitle').textContent = item.title;
    document.getElementById('itemText').textContent = item.text;
    
    const imgElement = document.getElementById('itemImage');
    imgElement.src = item.image;
    imgElement.style.display = 'block';
    imgElement.onerror = function() {
        this.style.display = 'none';
    };
    
    document.getElementById('itemDialog').style.display = 'block';
}

function closeItemDialog() {
    isItemDialogOpen = false;
    document.getElementById('itemDialog').style.display = 'none';
}


function updateLabyrinth() {
    if (!isLabyrinthOpen || isItemDialogOpen) return;
    
    let moved = false;
    let newX = playerPos.x;
    let newY = playerPos.y;
    
    if (labyrinthKeys['w'] || labyrinthKeys['arrowup']) {
        newY--;
        moved = true;
    } else if (labyrinthKeys['s'] || labyrinthKeys['arrowdown']) {
        newY++;
        moved = true;
    } else if (labyrinthKeys['a'] || labyrinthKeys['arrowleft']) {
        newX--;
        moved = true;
    } else if (labyrinthKeys['d'] || labyrinthKeys['arrowright']) {
        newX++;
        moved = true;
    }
    
    // Check if new position is valid (not a wall)
    if (moved && labyrinthMaze[newY] && labyrinthMaze[newY][newX] !== 0) {
        const currentTime = Date.now();
        if (currentTime - lastMoveTime < moveDelay) return; // Cooldown check
        
        playerPos.x = newX;
        playerPos.y = newY;
        lastMoveTime = currentTime;
        
        // Check if player collected placeholder item
        if (labyrinthMaze[newY][newX] === 2) {
            labyrinthMaze[newY][newX] = 1; // Remove item
            showItemDialog(collectedItems);
            collectedItems++;
            console.log('Collected item ' + collectedItems);
        }
        
        // Check if player reached the end
        if (labyrinthMaze[newY][newX] === 3) {
            closeLabyrinth();
            collectedItems = 0; // Reset for next time
        }
        
        drawLabyrinth();
    }
}

function openMemoriesPage() {
    document.getElementById('memoriesPage').style.display = 'block';
    document.exitPointerLock();
    populateMemories();
}

function closeMemoriesPage() {
    document.getElementById('memoriesPage').style.display = 'none';
    renderer.domElement.requestPointerLock();
}

function populateMemories() {
    const container = document.getElementById('memoriesContent');
    
    // Clear existing content except title
    const title = container.querySelector('h1');
    container.innerHTML = '';
    container.appendChild(title);
    
    // Add all memory items
    itemData.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'memory-item';
        div.innerHTML = `
            <h2>${item.title}</h2>
            <img src="${item.image}" alt="${item.title}" onerror="this.style.display='none'">
            <p>${item.text}</p>
        `;
        container.appendChild(div);
    });
}

function openLetterPage() {
       document.getElementById('letterPage').style.display = 'block';
       document.exitPointerLock();
   }
   
   function closeLetterPage() {
       document.getElementById('letterPage').style.display = 'none';
       renderer.domElement.requestPointerLock();
   }
        // Movement
        function updateMovement() {
            if (currentMemory) return;

            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            if (keys['w'] || keys['arrowup']) {
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }
            if (keys['s'] || keys['arrowdown']) {
                camera.position.add(forward.multiplyScalar(-moveSpeed));
            }
            if (keys['a'] || keys['arrowleft']) {
                camera.position.add(right.multiplyScalar(-moveSpeed));
            }
            if (keys['d'] || keys['arrowright']) {
                camera.position.add(right.multiplyScalar(moveSpeed));
            }

            // Keep player in corridor bounds
            camera.position.x = Math.max(-2.5, Math.min(2.5, camera.position.x));
            camera.position.z = Math.max(-175, Math.min(5, camera.position.z));
            camera.position.y = 1.6;

            // Update light position
            pointLight.position.copy(camera.position);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = mouseX;
            camera.rotation.x = mouseY;

            updateMovement();
            checkMemoryProximity();
            checkFloatingTexts();
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>




